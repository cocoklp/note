索引基于什么数据结构
B+树实现细节
B-树和B+树区别
联合索引在B+树怎么存储


索引
	二叉树的查找速度和比较次数都是最小的，但是数据库索引是存储在磁盘的
	逐一加载每一个磁盘页，磁盘对应着索引树的节点
	最坏的情况下，磁盘IO次数等于索引树的高度
	使用B树和B+树可以减小树的高度
B-树
	https://www.sohu.com/a/154640931_478315
	B树，不是B减树
	多路平衡查找树，每一个节点最多包含k个孩子，k成为b树的阶，取决于磁盘页的大小
	下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征：

	1.根结点至少有两个子女。

	2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

	3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

	4.所有的叶子结点都位于同一层。

	5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。


B+树
https://blog.csdn.net/qq_26222859/article/details/80631121
根节点的最大元素，等同于整个B+树的最大元素，无论删除插入多少元素，都要保持最大元素在根节点
卫星数据
	索引元素所指向的数据记录，比如数据库的某一行，B+树中只有叶子节点带有卫星数据，中间节点仅仅是索引。（聚集索引中叶子节点直接包含卫星数据。非聚集索引叶子节点带有指向卫星数据 的指针）
B+树中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素，io小
查询范围时B-树需要中序遍历，B+树在叶子节点的链表遍历

B-树的结果可能在中间节点也可能在叶子节点，B+树肯定在叶子节点，更稳定

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

索引优点：
	唯一索引可以保证数据唯一性
	加快检索速度
	加速表与表之间的连接
	分组和排序时，可以减少查询中分组和排序的时间
缺点：
	创建和维护索引耗时
	索引占用物理空间
	降低增删改效率
	索引太多会影响判断使用哪个索引

需要建立：
	主键
		为什么必须主键：Innodb使用B+树保存数据，数据以主键为根节点和中间节点保存，叶子节点保存数据，如果不指定，会挑选一个unique 且 非null的作为主键，没有则使用内置的rowid作为主键
	频繁作为查询条件的
	排序的（因为索引是有序的）
	查询中统计或分组的字段
不需要建立：
	频繁更新
	where中不需要的
	区分度不高的，比如性别只有男 女，不适合建立

索引分类：
	主键
	唯一索引
	普通索引
	联合索引（多个字段，怎么保存的？？？？）

语句优化：
	like '%aa' 不能命中，like 'a%'能命中
	union in or 可以命中  or使用不当会导致全表扫描
	!= <> not in 等负条件查询不能命中索引
	联合索引最左前缀原则
	联合索引时，区分度高的在最左边
	存在等号和费等好混合判断是，建立索引时把等号条件的列前置？？ 需要么？
	强制类型转换不能命中索引
	在字段上计算不能命中索引
	更新频繁、区分度低的不建立索引
	```
		区分度 count(distinct 列名)/count(*) > 80% 可以建立
	```
	建立索引的列不能为null，使用not null约束及默认值  ？？
	offset： 去offset+N行，然后放弃前offset行，返回N行
	明确只有一个结果，使用limit 1可以提高效率
	select 指明字段名称

https://blog.csdn.net/weixin_42220532/article/details/94049284

每个表都会有一个主键，mysql以主键的值构造一棵树，叶子节点存放主键对应的整行数据
自建的索引，叫辅助索引，是树的结构，默认从小到大排序，叶子节点存储索引和主键。
所以查询时，如果只是order by filed_name，filed_name有索引的话，直接获取符合条件的file_name，然后从叶子节点取出主键值，然后去主键的树，取出整行数据。
没有索引的话，只能在主键的树，全表扫描。
select查询的列，有索引的话，在索引树上就可以获取数据，不需要再到主键的树。
select a,b from table_name where a = **, 加 (a,b)联合索引，即可从辅助索引中取出完整结果。先按a排序，a相同再按b排序，索引where b=** 命中不了索引。
一次查询同一张表只能用一个索引，where a=1 and b=2，a b分别有单独索引，mysql会判断按哪个索引取得数据少，使用数据少的那个索引。或者是同通过 force index(index_name)指定索引。
explain  select ** From censor_lib force index  where  suggestion ='block' and user_pin ='testtest810';

join
	SELECT ** FROM t1 JOIN t2 ON t1.id = t2.id
	mysql先比较t1和t2哪个小，即行数少，假设t1少，就把t1的id全部取出来(全表扫描)，然后到t2里去根据这些id一个个查。小表决定循环次数，大表决定循环的查询时间。

	SELECT ** FROM t1 JOIN t2 ON t1.id = t2.id WHERE t1.addtime = XX AND t2.addtime = XXX
	按对两张表分别执行对应的查询条件，哪个开销小，哪个就是小表。如果t2 addtime有索引，t1没有，那么t2就是小表
	然后会根据id和addtime去查询t1，所以需要联合索引